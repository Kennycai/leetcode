# leetcode
- 0005 最長回文子串         （#動態規劃）[中等]
- 0300 最长递增子序列       （#動態規劃）[中等]
- 0198 打家劫舍            （#動態規劃）[中等]
- 0213 打家劫舍2           （#動態規劃）[中等]
- 0075 颜色分类            （#排序、#数组）[中等]
## 动态规划
1. 0005 最長回文子串
2. 0300 最长递增子序列
3. 0198 打家劫舍
4. 0213 打家劫舍2
   ![动态规划](../img/动态规划.png)

## 排序
- 稳定性：任何一个相同的值，在经过排序算法后，这些值的相对次序保持不变，则称这种排序算法是稳定的，否则称为不稳定的。
- 工程中的综合排序：大样本量的是时候基础数据用快排，普通类型用归并排序，小样本量时用插入排序
    - 原因：基本数据类型不关心稳定性，所以可以使用快排。小样本情况下插入排序的时间复杂度常数项很小，所以小样本情况下插入排序反而是优解
1. 冒泡排序
    - 时间复杂度：O(N^2)
    - 额外空间复杂度：O(1)
    - 稳定
2. 选择排序
    - 时间复杂度：O(N^2)
    - 额外空间复杂度：O(1)
    - 不稳定
3. 插入排序
    - 时间复杂度：O(N^2)
    - 额外空间复杂度：O(1)
    - 稳定
4. 归并排序
    - 时间复杂度：O(N*logN)
    - 额外空间复杂度：O(N)
    - 稳定
    - 扩展：将归并排序的额外空间复杂度变成O(1)的方法，搜索：归并排序 内部缓存法
5. 随机快排排序
    - 时间复杂度：O(N*logN)
    - 额外空间复杂度：O(logN)
    - 不稳定
    - 扩展：快排可以做到稳定性，搜索：01 stable sort；（相应问题：奇数放数组左边，偶数放数组右边，要求原始次序不变，时间复杂度O(N)，额外空间复杂度O(1)）\\
    - 扩展：leetcode_0075
6. 堆排序
    - 时间复杂度：O(N*logN)
    - 额外空间复杂度：O(1)
    - 不稳定
7. 桶排序（不基于比较）
    - 时间复杂度：O(N)
    - 额外空间复杂度：O(N)
    - 稳定
    - 非基于比较的排序，与被排序的样本的实际数据状况很有关系，所 以实际中并不经常使用
    - 扩展：leetcode_0164